[
  {
    "title": "ما الهدف الأساسي من تحليل الخوارزميات؟",
    "answer_1": "معرفة لغة البرمجة المناسبة",
    "answer_2": "قياس كفاءة الخوارزمية من حيث الزمن والذاكرة",
    "answer_3": "تقليل عدد المتغيرات",
    "answer_4": "تحسين شكل الكود فقط",
    "correct_ans": "قياس كفاءة الخوارزمية من حيث الزمن والذاكرة"
  },
  {
    "title": "ماذا تمثل Big-O Notation؟",
    "answer_1": "أفضل حالة لتنفيذ الخوارزمية",
    "answer_2": "أسوأ حالة لتنفيذ الخوارزمية",
    "answer_3": "متوسط زمن التنفيذ",
    "answer_4": "عدد الأسطر البرمجية",
    "correct_ans": "أسوأ حالة لتنفيذ الخوارزمية"
  },
  {
    "title": "أي مما يلي يُعد خوارزمية بحث؟",
    "answer_1": "Bubble Sort",
    "answer_2": "Binary Search",
    "answer_3": "Merge Sort",
    "answer_4": "Quick Sort",
    "correct_ans": "Binary Search"
  },
  {
    "title": "يشترط في Binary Search أن تكون البيانات:",
    "answer_1": "عشوائية",
    "answer_2": "مرتبة",
    "answer_3": "مصفوفة ثنائية",
    "answer_4": "مرتبطة بمؤشر",
    "correct_ans": "مرتبة"
  },
  {
    "title": "التعقيد الزمني لـ Binary Search هو:",
    "answer_1": "O(n)",
    "answer_2": "O(log n)",
    "answer_3": "O(n log n)",
    "answer_4": "O(1)",
    "correct_ans": "O(log n)"
  },
  {
    "title": "أي خوارزمية ترتيب تعتمد على المقارنة بين العناصر المتجاورة؟",
    "answer_1": "Selection Sort",
    "answer_2": "Insertion Sort",
    "answer_3": "Bubble Sort",
    "answer_4": "Merge Sort",
    "correct_ans": "Bubble Sort"
  },
  {
    "title": "التعقيد الزمني في أسوأ حالة لـ Bubble Sort هو:",
    "answer_1": "O(log n)",
    "answer_2": "O(n)",
    "answer_3": "O(n^2)",
    "answer_4": "O(1)",
    "correct_ans": "O(n^2)"
  },
  {
    "title": "أي خوارزمية تعتمد مبدأ Divide and Conquer؟",
    "answer_1": "Bubble Sort",
    "answer_2": "Insertion Sort",
    "answer_3": "Merge Sort",
    "answer_4": "Selection Sort",
    "correct_ans": "Merge Sort"
  },
  {
    "title": "ما التعقيد الزمني لـ Merge Sort في جميع الحالات؟",
    "answer_1": "O(n)",
    "answer_2": "O(n log n)",
    "answer_3": "O(n^2)",
    "answer_4": "O(log n)",
    "correct_ans": "O(n log n)"
  },
  {
    "title": "أي مما يلي يُعد مثالًا على خوارزمية Greedy؟",
    "answer_1": "Merge Sort",
    "answer_2": "Dijkstra",
    "answer_3": "Binary Search",
    "answer_4": "Bubble Sort",
    "correct_ans": "Dijkstra"
  },
  {
    "title": "ما المقصود بالتعقيد الزمني Time Complexity؟",
    "answer_1": "عدد الأسطر البرمجية",
    "answer_2": "الزمن اللازم لتنفيذ الخوارزمية بالنسبة لحجم المدخلات",
    "answer_3": "حجم الذاكرة المستخدمة فقط",
    "answer_4": "لغة البرمجة المستخدمة",
    "correct_ans": "الزمن اللازم لتنفيذ الخوارزمية بالنسبة لحجم المدخلات"
  },
  {
    "title": "ما المقصود بالتعقيد المكاني Space Complexity؟",
    "answer_1": "عدد العمليات الحسابية",
    "answer_2": "الذاكرة الإضافية التي تستخدمها الخوارزمية",
    "answer_3": "زمن التنفيذ",
    "answer_4": "عدد المتغيرات فقط",
    "correct_ans": "الذاكرة الإضافية التي تستخدمها الخوارزمية"
  },
  {
    "title": "أي مما يلي يمثل أفضل حالة Best Case؟",
    "answer_1": "أطول زمن تنفيذ",
    "answer_2": "أقصر زمن تنفيذ",
    "answer_3": "الزمن المتوسط",
    "answer_4": "زمن ثابت دائمًا",
    "correct_ans": "أقصر زمن تنفيذ"
  },
  {
    "title": "في Linear Search، متى تكون أسوأ حالة؟",
    "answer_1": "عندما يكون العنصر في البداية",
    "answer_2": "عندما يكون العنصر في الوسط",
    "answer_3": "عندما يكون العنصر في النهاية أو غير موجود",
    "answer_4": "عندما تكون المصفوفة مرتبة",
    "correct_ans": "عندما يكون العنصر في النهاية أو غير موجود"
  },
  {
    "title": "التعقيد الزمني لـ Linear Search هو:",
    "answer_1": "O(1)",
    "answer_2": "O(log n)",
    "answer_3": "O(n)",
    "answer_4": "O(n log n)",
    "correct_ans": "O(n)"
  },
  {
    "title": "أي خوارزمية ترتيب تقوم بإدخال العنصر في مكانه الصحيح ضمن الجزء المرتب؟",
    "answer_1": "Bubble Sort",
    "answer_2": "Insertion Sort",
    "answer_3": "Selection Sort",
    "answer_4": "Quick Sort",
    "correct_ans": "Insertion Sort"
  },
  {
    "title": "في Selection Sort، كم عدد عمليات التبديل Swap في أسوأ حالة؟",
    "answer_1": "n",
    "answer_2": "n - 1",
    "answer_3": "n^2",
    "answer_4": "log n",
    "correct_ans": "n - 1"
  },
  {
    "title": "أي خوارزمية ترتيب تُعد مستقرة Stable؟",
    "answer_1": "Quick Sort",
    "answer_2": "Selection Sort",
    "answer_3": "Bubble Sort",
    "answer_4": "Heap Sort",
    "correct_ans": "Bubble Sort"
  },
  {
    "title": "ما المقصود بخاصية الاستقرار Stability في خوارزميات الترتيب؟",
    "answer_1": "عدم تغيير حجم المصفوفة",
    "answer_2": "الحفاظ على ترتيب العناصر المتساوية",
    "answer_3": "تقليل الذاكرة المستخدمة",
    "answer_4": "تقليل عدد المقارنات",
    "correct_ans": "الحفاظ على ترتيب العناصر المتساوية"
  },
  {
    "title": "أي خوارزمية تعتمد على اختيار محور Pivot؟",
    "answer_1": "Merge Sort",
    "answer_2": "Quick Sort",
    "answer_3": "Bubble Sort",
    "answer_4": "Insertion Sort",
    "correct_ans": "Quick Sort"
  },
  {
    "title": "التعقيد الزمني في أسوأ حالة لـ Quick Sort هو:",
    "answer_1": "O(n log n)",
    "answer_2": "O(log n)",
    "answer_3": "O(n^2)",
    "answer_4": "O(n)",
    "correct_ans": "O(n^2)"
  },
  {
    "title": "أي مما يلي يُعد مثالًا على خوارزمية تعتمد البرمجة الديناميكية؟",
    "answer_1": "Binary Search",
    "answer_2": "Fibonacci باستخدام Memoization",
    "answer_3": "Bubble Sort",
    "answer_4": "Selection Sort",
    "correct_ans": "Fibonacci باستخدام Memoization"
  },
  {
    "title": "ما المقصود بـ Worst Case Time Complexity؟",
    "answer_1": "أقصر زمن تنفيذ للخوارزمية",
    "answer_2": "أطول زمن تنفيذ للخوارزمية",
    "answer_3": "الزمن المتوسط للتنفيذ",
    "answer_4": "زمن التنفيذ في حالة ثابتة",
    "correct_ans": "أطول زمن تنفيذ للخوارزمية"
  },
  {
    "title": "إذا كان T(n) = T(n/2) + O(1) فإن التعقيد الزمني هو:",
    "answer_1": "O(n)",
    "answer_2": "O(log n)",
    "answer_3": "O(n log n)",
    "answer_4": "O(1)",
    "correct_ans": "O(log n)"
  },
  {
    "title": "أي من التالي يُستخدم لحل علاقات العودية Recurrence Relations؟",
    "answer_1": "Greedy Method",
    "answer_2": "Master Theorem",
    "answer_3": "Binary Search",
    "answer_4": "Backtracking",
    "correct_ans": "Master Theorem"
  },
  {
    "title": "في Heap، أي خاصية يجب أن تتحقق دائمًا؟",
    "answer_1": "أن يكون المخطط ثنائي القسمين",
    "answer_2": "أن تكون شجرة ثنائية كاملة",
    "answer_3": "أن تكون جميع العقد متساوية",
    "answer_4": "أن تكون القيم مرتبة تصاعديًا بالكامل",
    "correct_ans": "أن تكون شجرة ثنائية كاملة"
  },
  {
    "title": "في Max-Heap تكون قيمة الجذر:",
    "answer_1": "أصغر قيمة في الشجرة",
    "answer_2": "أكبر قيمة في الشجرة",
    "answer_3": "متوسطة بين القيم",
    "answer_4": "غير محددة",
    "correct_ans": "أكبر قيمة في الشجرة"
  },
  {
    "title": "التعقيد الزمني لبناء Heap من مصفوفة هو:",
    "answer_1": "O(n)",
    "answer_2": "O(n log n)",
    "answer_3": "O(log n)",
    "answer_4": "O(n^2)",
    "correct_ans": "O(n)"
  },
  {
    "title": "ما الهدف من استخدام Hash Table؟",
    "answer_1": "ترتيب البيانات",
    "answer_2": "البحث السريع عن البيانات",
    "answer_3": "تقليل حجم الذاكرة فقط",
    "answer_4": "تنفيذ العمليات التكرارية",
    "correct_ans": "البحث السريع عن البيانات"
  },
  {
    "title": "في Hashing، ماذا يحدث عند حدوث Collision؟",
    "answer_1": "يتم تجاهل العنصر الجديد",
    "answer_2": "تخزين عنصرين في نفس الموقع",
    "answer_3": "يتم استخدام طريقة لمعالجة التصادم",
    "answer_4": "يحدث خطأ في البرنامج",
    "correct_ans": "يتم استخدام طريقة لمعالجة التصادم"
  },
  {
    "title": "أي من التالي يُعد طريقة لمعالجة Collision في Hashing؟",
    "answer_1": "Binary Search",
    "answer_2": "Chaining",
    "answer_3": "Divide and Conquer",
    "answer_4": "Greedy",
    "correct_ans": "Chaining"
  },
  {
    "title": "الخاصية الأساسية في Dynamic Programming هي:",
    "answer_1": "تقسيم المشكلة فقط",
    "answer_2": "وجود تداخل في المشاكل الجزئية",
    "answer_3": "استخدام العشوائية",
    "answer_4": "العمل دون ذاكرة إضافية",
    "correct_ans": "وجود تداخل في المشاكل الجزئية"
  },
  {
    "title": "أي من التالي يُعد مثالًا على Dynamic Programming؟",
    "answer_1": "Binary Search",
    "answer_2": "Floyd-Warshall",
    "answer_3": "DFS",
    "answer_4": "Selection Sort",
    "correct_ans": "Floyd-Warshall"
  },
  {
    "title": "في خوارزمية Dijkstra، الشرط الأساسي لعملها بشكل صحيح هو:",
    "answer_1": "وجود أوزان سالبة",
    "answer_2": "عدم وجود أوزان سالبة",
    "answer_3": "أن يكون المخطط ثنائي",
    "answer_4": "أن يكون المخطط غير متصل",
    "correct_ans": "عدم وجود أوزان سالبة"
  },
  {
    "title": "ما الفرق الأساسي بين Worst Case و Average Case Time Complexity؟",
    "answer_1": "لا يوجد فرق",
    "answer_2": "Worst Case يمثل أطول زمن تنفيذ، و Average Case يمثل الزمن المتوقع",
    "answer_3": "Average Case يمثل أطول زمن تنفيذ",
    "answer_4": "Worst Case يمثل أفضل زمن تنفيذ",
    "correct_ans": "Worst Case يمثل أطول زمن تنفيذ، و Average Case يمثل الزمن المتوقع"
  },
  {
    "title": "إذا كانت علاقة العودية T(n) = 2T(n/2) + O(n) فإن التعقيد الزمني هو:",
    "answer_1": "O(n)",
    "answer_2": "O(log n)",
    "answer_3": "O(n log n)",
    "answer_4": "O(n^2)",
    "correct_ans": "O(n log n)"
  },
  {
    "title": "متى لا يمكن استخدام Master Theorem لحل علاقة العودية؟",
    "answer_1": "عندما تكون العلاقة من الشكل T(n)=aT(n/b)+f(n)",
    "answer_2": "عندما لا تكون العلاقة قابلة للتقسيم",
    "answer_3": "عندما لا تنطبق حالات Master الثلاث",
    "answer_4": "عندما يكون f(n)=O(1)",
    "correct_ans": "عندما لا تنطبق حالات Master الثلاث"
  },

  {
    "title": "ما الشرط الأساسي لتحقيق خاصية Heap Property؟",
    "answer_1": "أن تكون الشجرة متوازنة فقط",
    "answer_2": "أن تكون شجرة ثنائية كاملة مع احترام ترتيب القيم",
    "answer_3": "أن تكون جميع القيم مختلفة",
    "answer_4": "أن تكون الشجرة ثنائية البحث",
    "correct_ans": "أن تكون شجرة ثنائية كاملة مع احترام ترتيب القيم"
  },
  {
    "title": "أي عملية في Heap تحتاج زمن O(log n)؟",
    "answer_1": "الوصول إلى الجذر",
    "answer_2": "إدخال عنصر جديد",
    "answer_3": "بناء Heap كامل",
    "answer_4": "قراءة جميع العناصر",
    "correct_ans": "إدخال عنصر جديد"
  },
  {
    "title": "لماذا لا يُعتبر Heap شجرة بحث ثنائية (BST)؟",
    "answer_1": "لأن الجذر ليس أكبر عنصر دائمًا",
    "answer_2": "لأن ترتيب العقد لا يحقق شرط BST",
    "answer_3": "لأن Heap لا يحتوي أوراق",
    "answer_4": "لأن Heap لا يستخدم المقارنات",
    "correct_ans": "لأن ترتيب العقد لا يحقق شرط BST"
  },

  {
    "title": "ما الهدف من استخدام عامل التحميل Load Factor في Hashing؟",
    "answer_1": "زيادة حجم الجدول",
    "answer_2": "قياس مدى امتلاء جدول التجزئة",
    "answer_3": "تقليل عدد المفاتيح",
    "answer_4": "إلغاء التصادم",
    "correct_ans": "قياس مدى امتلاء جدول التجزئة"
  },
  {
    "title": "أي طريقة لمعالجة التصادم تعتمد على البحث في مواقع متتالية؟",
    "answer_1": "Chaining",
    "answer_2": "Double Hashing",
    "answer_3": "Linear Probing",
    "answer_4": "Divide and Conquer",
    "correct_ans": "Linear Probing"
  },
  {
    "title": "ما أسوأ حالة زمنية للبحث في Hash Table؟",
    "answer_1": "O(1)",
    "answer_2": "O(log n)",
    "answer_3": "O(n)",
    "answer_4": "O(n log n)",
    "correct_ans": "O(n)"
  },

  {
    "title": "ما الفرق الجوهري بين Greedy و Dynamic Programming؟",
    "answer_1": "Greedy يستخدم الذاكرة و DP لا يستخدمها",
    "answer_2": "Greedy يختار الحل المحلي، و DP يضمن الحل الأمثل",
    "answer_3": "DP أسرع دائمًا",
    "answer_4": "Greedy أبطأ من DP",
    "correct_ans": "Greedy يختار الحل المحلي، و DP يضمن الحل الأمثل"
  },
  {
    "title": "أي شرط يجب أن يتحقق لتطبيق Dynamic Programming؟",
    "answer_1": "وجود دورات في المشكلة",
    "answer_2": "عدم وجود مشاكل جزئية",
    "answer_3": "تداخل المشاكل الجزئية",
    "answer_4": "وجود بيانات مرتبة",
    "correct_ans": "تداخل المشاكل الجزئية"
  },

  {
    "title": "أي خوارزمية تستخدم لإيجاد أقصر مسار بين جميع أزواج العقد؟",
    "answer_1": "Dijkstra",
    "answer_2": "Prim",
    "answer_3": "Floyd-Warshall",
    "answer_4": "DFS",
    "correct_ans": "Floyd-Warshall"
  },
  {
    "title": "ما الفرق الأساسي بين BFS و DFS؟",
    "answer_1": "BFS يستخدم Stack و DFS يستخدم Queue",
    "answer_2": "BFS يبحث بالمستويات و DFS يتعمق أولًا",
    "answer_3": "DFS أسرع دائمًا",
    "answer_4": "لا يوجد فرق",
    "correct_ans": "BFS يبحث بالمستويات و DFS يتعمق أولًا"
  },
  {
    "title": "ما الهدف من تحليل الخوارزميات؟",
    "answer_1": "تقليل عدد المتغيرات",
    "answer_2": "قياس كفاءة الخوارزمية من حيث الزمن والذاكرة",
    "answer_3": "تحسين شكل الكود",
    "answer_4": "اختيار لغة البرمجة",
    "correct_ans": "قياس كفاءة الخوارزمية من حيث الزمن والذاكرة"
  },
  {
    "title": "ما الذي تمثله Big-O Notation؟",
    "answer_1": "أفضل حالة تنفيذ",
    "answer_2": "أسوأ حالة تنفيذ",
    "answer_3": "متوسط التنفيذ",
    "answer_4": "عدد الأسطر",
    "correct_ans": "أسوأ حالة تنفيذ"
  },
  {
    "title": "أي مما يلي يمثل Best Case؟",
    "answer_1": "أطول زمن تنفيذ",
    "answer_2": "أقصر زمن تنفيذ",
    "answer_3": "زمن عشوائي",
    "answer_4": "زمن ثابت",
    "correct_ans": "أقصر زمن تنفيذ"
  },
  {
    "title": "التعقيد الزمني لـ Linear Search هو:",
    "answer_1": "O(1)",
    "answer_2": "O(log n)",
    "answer_3": "O(n)",
    "answer_4": "O(n log n)",
    "correct_ans": "O(n)"
  },
  {
    "title": "شرط استخدام Binary Search هو أن تكون البيانات:",
    "answer_1": "عشوائية",
    "answer_2": "مرتبة",
    "answer_3": "ثنائية",
    "answer_4": "غير مكررة",
    "correct_ans": "مرتبة"
  },
  {
    "title": "التعقيد الزمني لـ Binary Search هو:",
    "answer_1": "O(n)",
    "answer_2": "O(log n)",
    "answer_3": "O(n log n)",
    "answer_4": "O(1)",
    "correct_ans": "O(log n)"
  },
  {
    "title": "أي خوارزمية ترتيب تعتمد المقارنة بين العناصر المتجاورة؟",
    "answer_1": "Insertion Sort",
    "answer_2": "Selection Sort",
    "answer_3": "Bubble Sort",
    "answer_4": "Merge Sort",
    "correct_ans": "Bubble Sort"
  },
  {
    "title": "التعقيد الزمني في أسوأ حالة لـ Bubble Sort هو:",
    "answer_1": "O(n)",
    "answer_2": "O(log n)",
    "answer_3": "O(n^2)",
    "answer_4": "O(1)",
    "correct_ans": "O(n^2)"
  },
  {
    "title": "أي خوارزمية تعتمد مبدأ Divide and Conquer؟",
    "answer_1": "Bubble Sort",
    "answer_2": "Insertion Sort",
    "answer_3": "Merge Sort",
    "answer_4": "Selection Sort",
    "correct_ans": "Merge Sort"
  },
  {
    "title": "التعقيد الزمني لـ Merge Sort في جميع الحالات هو:",
    "answer_1": "O(n)",
    "answer_2": "O(log n)",
    "answer_3": "O(n log n)",
    "answer_4": "O(n^2)",
    "correct_ans": "O(n log n)"
  },
  {
    "title": "أي خوارزمية ترتيب تعتمد اختيار Pivot؟",
    "answer_1": "Merge Sort",
    "answer_2": "Quick Sort",
    "answer_3": "Bubble Sort",
    "answer_4": "Selection Sort",
    "correct_ans": "Quick Sort"
  },
  {
    "title": "أسوأ حالة زمنية لـ Quick Sort هي:",
    "answer_1": "O(n)",
    "answer_2": "O(log n)",
    "answer_3": "O(n log n)",
    "answer_4": "O(n^2)",
    "correct_ans": "O(n^2)"
  },
  {
    "title": "ما المقصود بخاصية Stability في الترتيب؟",
    "answer_1": "سرعة التنفيذ",
    "answer_2": "الحفاظ على ترتيب العناصر المتساوية",
    "answer_3": "تقليل الذاكرة",
    "answer_4": "تقليل المقارنات",
    "correct_ans": "الحفاظ على ترتيب العناصر المتساوية"
  },
  {
    "title": "أي خوارزمية ترتيب تُعد مستقرة؟",
    "answer_1": "Quick Sort",
    "answer_2": "Selection Sort",
    "answer_3": "Bubble Sort",
    "answer_4": "Heap Sort",
    "correct_ans": "Bubble Sort"
  },
  {
    "title": "إذا كانت T(n) = T(n/2) + O(1) فإن التعقيد هو:",
    "answer_1": "O(n)",
    "answer_2": "O(log n)",
    "answer_3": "O(n log n)",
    "answer_4": "O(1)",
    "correct_ans": "O(log n)"
  },
  {
    "title": "إذا كانت T(n) = 2T(n/2) + O(n) فإن التعقيد هو:",
    "answer_1": "O(n)",
    "answer_2": "O(log n)",
    "answer_3": "O(n log n)",
    "answer_4": "O(n^2)",
    "correct_ans": "O(n log n)"
  },
  {
    "title": "ما الأداة المستخدمة لحل Recurrence Relations؟",
    "answer_1": "Greedy",
    "answer_2": "Binary Search",
    "answer_3": "Master Theorem",
    "answer_4": "Backtracking",
    "correct_ans": "Master Theorem"
  },
  {
    "title": "في Heap يجب أن تكون البنية:",
    "answer_1": "شجرة ثنائية كاملة",
    "answer_2": "شجرة بحث",
    "answer_3": "شجرة متوازنة فقط",
    "answer_4": "مصفوفة مرتبة",
    "correct_ans": "شجرة ثنائية كاملة"
  },
  {
    "title": "في Max Heap تكون قيمة الجذر:",
    "answer_1": "أصغر قيمة",
    "answer_2": "أكبر قيمة",
    "answer_3": "قيمة عشوائية",
    "answer_4": "متوسطة",
    "correct_ans": "أكبر قيمة"
  },
  {
    "title": "التعقيد الزمني لبناء Heap من مصفوفة هو:",
    "answer_1": "O(n)",
    "answer_2": "O(n log n)",
    "answer_3": "O(log n)",
    "answer_4": "O(n^2)",
    "correct_ans": "O(n)"
  },
  {
    "title": "ما الهدف من Hash Table؟",
    "answer_1": "ترتيب البيانات",
    "answer_2": "البحث السريع",
    "answer_3": "تقليل الذاكرة",
    "answer_4": "النسخ الاحتياطي",
    "correct_ans": "البحث السريع"
  },
  {
    "title": "عند حدوث Collision في Hashing يتم:",
    "answer_1": "تجاهل العنصر",
    "answer_2": "إيقاف البرنامج",
    "answer_3": "استخدام طريقة معالجة تصادم",
    "answer_4": "إعادة الترتيب",
    "correct_ans": "استخدام طريقة معالجة تصادم"
  },
  {
    "title": "أي من التالي طريقة لمعالجة Collision؟",
    "answer_1": "Chaining",
    "answer_2": "Binary Search",
    "answer_3": "Merge Sort",
    "answer_4": "DFS",
    "correct_ans": "Chaining"
  },
  {
    "title": "الخاصية الأساسية في Dynamic Programming هي:",
    "answer_1": "عدم استخدام الذاكرة",
    "answer_2": "تداخل المشاكل الجزئية",
    "answer_3": "اختيار محلي",
    "answer_4": "العشوائية",
    "correct_ans": "تداخل المشاكل الجزئية"
  },
  {
    "title": "أي خوارزمية تُعد مثالًا على Dynamic Programming؟",
    "answer_1": "Binary Search",
    "answer_2": "Floyd-Warshall",
    "answer_3": "Bubble Sort",
    "answer_4": "Selection Sort",
    "correct_ans": "Floyd-Warshall"
  },
  {
    "title": "ما الفرق الأساسي بين Greedy و Dynamic Programming؟",
    "answer_1": "Greedy أبطأ دائمًا",
    "answer_2": "Greedy لا يضمن الحل الأمثل دائمًا",
    "answer_3": "DP لا يستخدم ذاكرة",
    "answer_4": "لا فرق",
    "correct_ans": "Greedy لا يضمن الحل الأمثل دائمًا"
  },
  {
    "title": "في خوارزمية Dijkstra يجب أن تكون الأوزان:",
    "answer_1": "سالبة",
    "answer_2": "موجبة أو صفرية",
    "answer_3": "عشوائية",
    "answer_4": "غير مهمة",
    "correct_ans": "موجبة أو صفرية"
  },
  {
    "title": "أي خوارزمية تستخدم لإيجاد أقصر مسار بين جميع الأزواج؟",
    "answer_1": "Dijkstra",
    "answer_2": "Prim",
    "answer_3": "Floyd-Warshall",
    "answer_4": "DFS",
    "correct_ans": "Floyd-Warshall"
  },
  {
    "title": "الفرق بين BFS و DFS هو أن:",
    "answer_1": "BFS يستخدم Stack",
    "answer_2": "DFS يستخدم Queue",
    "answer_3": "BFS يبحث بالمستويات و DFS يتعمق أولًا",
    "answer_4": "لا يوجد فرق",
    "correct_ans": "BFS يبحث بالمستويات و DFS يتعمق أولًا"
  },
  {
    "title": "ما السبب الرئيسي لاستخدام تحليل Amortized؟",
    "answer_1": "لقياس أسوأ حالة فقط",
    "answer_2": "لقياس متوسط تكلفة سلسلة عمليات",
    "answer_3": "لقياس أفضل حالة",
    "answer_4": "لقياس عدد المتغيرات",
    "correct_ans": "لقياس متوسط تكلفة سلسلة عمليات"
  },
  {
    "title": "أي من الطرق التالية تُستخدم في Amortized Analysis؟",
    "answer_1": "Greedy Method",
    "answer_2": "Accounting Method",
    "answer_3": "Divide and Conquer",
    "answer_4": "Backtracking",
    "correct_ans": "Accounting Method"
  },
  {
    "title": "في الخوارزميات التراجعية Recursion، أين يتم تخزين الاستدعاءات؟",
    "answer_1": "Heap",
    "answer_2": "Queue",
    "answer_3": "Stack",
    "answer_4": "Array",
    "correct_ans": "Stack"
  },
  {
    "title": "ما الخطر الأساسي من استخدام Recursion بدون شرط توقف؟",
    "answer_1": "بطء التنفيذ فقط",
    "answer_2": "حدوث Stack Overflow",
    "answer_3": "زيادة الذاكرة فقط",
    "answer_4": "نتائج خاطئة",
    "correct_ans": "حدوث Stack Overflow"
  },
  {
    "title": "متى تكون الخوارزمية التراجعية مكافئة للحل التكراري؟",
    "answer_1": "عندما تستخدم نفس عدد المتغيرات",
    "answer_2": "عندما تنفذ نفس العمليات المنطقية",
    "answer_3": "عندما لا تستخدم Stack",
    "answer_4": "عندما تكون أسرع",
    "correct_ans": "عندما تنفذ نفس العمليات المنطقية"
  },

  {
    "title": "أي عملية في Heap لا تحتاج إعادة ترتيب؟",
    "answer_1": "إدخال عنصر",
    "answer_2": "حذف الجذر",
    "answer_3": "الوصول إلى الجذر",
    "answer_4": "بناء Heap",
    "correct_ans": "الوصول إلى الجذر"
  },
  {
    "title": "في Min-Heap تكون العلاقة الصحيحة هي:",
    "answer_1": "قيمة الأب أكبر من الأبناء",
    "answer_2": "قيمة الأب أصغر أو تساوي الأبناء",
    "answer_3": "الأبناء متساوون دائمًا",
    "answer_4": "الشجرة مرتبة بالكامل",
    "correct_ans": "قيمة الأب أصغر أو تساوي الأبناء"
  },
  {
    "title": "أي خوارزمية تعتمد Heap بشكل أساسي؟",
    "answer_1": "Merge Sort",
    "answer_2": "Heap Sort",
    "answer_3": "Quick Sort",
    "answer_4": "Insertion Sort",
    "correct_ans": "Heap Sort"
  },
  {
    "title": "التعقيد الزمني لـ Heap Sort هو:",
    "answer_1": "O(n)",
    "answer_2": "O(log n)",
    "answer_3": "O(n log n)",
    "answer_4": "O(n^2)",
    "correct_ans": "O(n log n)"
  },

  {
    "title": "ما العامل الذي يؤثر مباشرة على عدد التصادمات في Hashing؟",
    "answer_1": "حجم المصفوفة فقط",
    "answer_2": "دالة التجزئة وجودتها",
    "answer_3": "لغة البرمجة",
    "answer_4": "نوع البيانات",
    "correct_ans": "دالة التجزئة وجودتها"
  },
  {
    "title": "أي قيمة لعامل التحميل Load Factor تزيد التصادمات؟",
    "answer_1": "قيمة صغيرة جدًا",
    "answer_2": "قيمة قريبة من الصفر",
    "answer_3": "قيمة قريبة من 1",
    "answer_4": "قيمة سالبة",
    "correct_ans": "قيمة قريبة من 1"
  },
  {
    "title": "في Chaining، أين يتم تخزين العناصر المتصادمة؟",
    "answer_1": "في جدول جديد",
    "answer_2": "في قائمة مرتبطة عند نفس الفهرس",
    "answer_3": "في Stack",
    "answer_4": "في Heap",
    "correct_ans": "في قائمة مرتبطة عند نفس الفهرس"
  },

  {
    "title": "لماذا لا تضمن Greedy دائمًا الحل الأمثل؟",
    "answer_1": "لأنها بطيئة",
    "answer_2": "لأنها تتخذ قرارات محلية",
    "answer_3": "لأنها تستخدم الذاكرة",
    "answer_4": "لأنها معقدة",
    "correct_ans": "لأنها تتخذ قرارات محلية"
  },
  {
    "title": "أي خاصية يجب إثباتها لضمان صحة خوارزمية Greedy؟",
    "answer_1": "Optimal Substructure",
    "answer_2": "Greedy Choice Property",
    "answer_3": "Overlapping Subproblems",
    "answer_4": "Recursion",
    "correct_ans": "Greedy Choice Property"
  },

  {
    "title": "في Dynamic Programming، ماذا تعني Memoization؟",
    "answer_1": "إعادة الحساب في كل مرة",
    "answer_2": "تخزين نتائج المشاكل الجزئية",
    "answer_3": "حذف النتائج القديمة",
    "answer_4": "تنفيذ الحل عكسيًا",
    "correct_ans": "تخزين نتائج المشاكل الجزئية"
  },
  {
    "title": "أي فرق بين Memoization و Tabulation؟",
    "answer_1": "Memoization من الأعلى للأسفل و Tabulation من الأسفل للأعلى",
    "answer_2": "Tabulation أبطأ دائمًا",
    "answer_3": "Memoization لا يستخدم ذاكرة",
    "answer_4": "لا يوجد فرق",
    "correct_ans": "Memoization من الأعلى للأسفل و Tabulation من الأسفل للأعلى"
  },
  {
    "title": "لماذا Dynamic Programming أسرع من Recursion البسيطة؟",
    "answer_1": "لأنها تستخدم لغة مختلفة",
    "answer_2": "لأنها تتجنب إعادة حساب نفس القيم",
    "answer_3": "لأنها لا تستخدم Stack",
    "answer_4": "لأنها أبسط",
    "correct_ans": "لأنها تتجنب إعادة حساب نفس القيم"
  },

  {
    "title": "أي خوارزمية تستخدم لإيجاد Minimum Spanning Tree؟",
    "answer_1": "Dijkstra",
    "answer_2": "Prim أو Kruskal",
    "answer_3": "DFS",
    "answer_4": "Floyd-Warshall",
    "correct_ans": "Prim أو Kruskal"
  },
  {
    "title": "ما الشرط الأساسي لعمل Kruskal بشكل صحيح؟",
    "answer_1": "أن يكون المخطط موجهًا",
    "answer_2": "أن لا تتشكل دورات",
    "answer_3": "أن تكون الأوزان موجبة",
    "answer_4": "أن يكون المخطط ثنائي",
    "correct_ans": "أن لا تتشكل دورات"
  },
  {
    "title": "أي بنية بيانات تُستخدم عادة مع Kruskal؟",
    "answer_1": "Stack",
    "answer_2": "Queue",
    "answer_3": "Disjoint Set (Union-Find)",
    "answer_4": "Heap",
    "correct_ans": "Disjoint Set (Union-Find)"
  },
  {
    "title": "ما التعقيد الزمني التقريبي لـ BFS باستخدام قائمة مجاورة؟",
    "answer_1": "O(V)",
    "answer_2": "O(E)",
    "answer_3": "O(V + E)",
    "answer_4": "O(V log E)",
    "correct_ans": "O(V + E)"
  },
  {
    "title": "ما التعقيد الزمني التقريبي لـ DFS باستخدام قائمة مجاورة؟",
    "answer_1": "O(V)",
    "answer_2": "O(E)",
    "answer_3": "O(V + E)",
    "answer_4": "O(E log V)",
    "correct_ans": "O(V + E)"
  },
  {
    "title": "متى تكون Big-O و Theta متساويتين؟",
    "answer_1": "عندما تمثل Big-O أفضل حالة",
    "answer_2": "عندما تمثل Theta حدًا علويًا فقط",
    "answer_3": "عندما يكون الحد العلوي والسفلي متماثلين",
    "answer_4": "عندما يكون التعقيد ثابتًا",
    "correct_ans": "عندما يكون الحد العلوي والسفلي متماثلين"
  },
  {
    "title": "أي مما يلي لا يؤثر على التعقيد الزمني للخوارزمية؟",
    "answer_1": "حجم المدخلات",
    "answer_2": "عدد العمليات",
    "answer_3": "لغة البرمجة المستخدمة",
    "answer_4": "بنية الخوارزمية",
    "correct_ans": "لغة البرمجة المستخدمة"
  },
  {
    "title": "إذا كانت خوارزمية تعمل بزمن O(n) وزمن O(n^2) في حالات مختلفة، فما هو Big-O النهائي؟",
    "answer_1": "O(n)",
    "answer_2": "O(n log n)",
    "answer_3": "O(n^2)",
    "answer_4": "O(1)",
    "correct_ans": "O(n^2)"
  },
  {
    "title": "أي علاقة عودية لا يمكن حلها مباشرة باستخدام Master Theorem؟",
    "answer_1": "T(n)=2T(n/2)+n",
    "answer_2": "T(n)=T(n/2)+1",
    "answer_3": "T(n)=T(n-1)+n",
    "answer_4": "T(n)=4T(n/2)+n^2",
    "correct_ans": "T(n)=T(n-1)+n"
  },

  {
    "title": "لماذا لا يكون Quick Sort مستقرًا بشكل افتراضي؟",
    "answer_1": "لأنه بطيء",
    "answer_2": "لأن عملية التقسيم تغير ترتيب العناصر المتساوية",
    "answer_3": "لأنه يستخدم Pivot",
    "answer_4": "لأنه يعمل تراجعيًا",
    "correct_ans": "لأن عملية التقسيم تغير ترتيب العناصر المتساوية"
  },
  {
    "title": "في أي حالة يكون Quick Sort أسرع عمليًا من Merge Sort؟",
    "answer_1": "عندما تكون البيانات مرتبة",
    "answer_2": "عندما تكون الذاكرة محدودة",
    "answer_3": "عندما يكون اختيار Pivot جيدًا",
    "answer_4": "عندما يكون n صغيرًا فقط",
    "correct_ans": "عندما يكون اختيار Pivot جيدًا"
  },
  {
    "title": "لماذا يُعد Merge Sort غير مناسب للذاكرة المحدودة؟",
    "answer_1": "لأنه بطيء",
    "answer_2": "لأنه يحتاج ذاكرة إضافية",
    "answer_3": "لأنه غير مستقر",
    "answer_4": "لأنه لا يعمل تراجعيًا",
    "correct_ans": "لأنه يحتاج ذاكرة إضافية"
  },

  {
    "title": "ما الحالة التي تجعل Heap Sort مفضلًا على Quick Sort؟",
    "answer_1": "عندما نريد خوارزمية مستقرة",
    "answer_2": "عندما نريد ضمان أسوأ حالة O(n log n)",
    "answer_3": "عندما تكون البيانات شبه مرتبة",
    "answer_4": "عندما يكون n صغيرًا",
    "correct_ans": "عندما نريد ضمان أسوأ حالة O(n log n)"
  },
  {
    "title": "لماذا لا يمكن اعتبار Heap بنية مرتبة بالكامل؟",
    "answer_1": "لأن الجذر فقط مضمون",
    "answer_2": "لأن الأبناء غير موجودين",
    "answer_3": "لأن القيم متساوية",
    "answer_4": "لأنها ليست شجرة",
    "correct_ans": "لأن الجذر فقط مضمون"
  },

  {
    "title": "متى يفشل Hash Table في إعطاء أداء O(1)؟",
    "answer_1": "عند استخدام دالة تجزئة مثالية",
    "answer_2": "عند ارتفاع عدد التصادمات",
    "answer_3": "عند استخدام Chaining",
    "answer_4": "عند استخدام Load Factor منخفض",
    "correct_ans": "عند ارتفاع عدد التصادمات"
  },
  {
    "title": "أي حالة تمثل أسوأ أداء لـ Hash Table؟",
    "answer_1": "عندما تكون المفاتيح موزعة جيدًا",
    "answer_2": "عندما تتصادم كل المفاتيح",
    "answer_3": "عندما يكون الجدول كبيرًا",
    "answer_4": "عندما يكون Load Factor صغيرًا",
    "correct_ans": "عندما تتصادم كل المفاتيح"
  },

  {
    "title": "ما الشرط الذي يجعل Greedy Algorithm صحيحة؟",
    "answer_1": "Optimal Substructure فقط",
    "answer_2": "Overlapping Subproblems فقط",
    "answer_3": "Greedy Choice Property",
    "answer_4": "استخدام الذاكرة",
    "correct_ans": "Greedy Choice Property"
  },
  {
    "title": "أي مشكلة لا يمكن حلها باستخدام Greedy بشكل صحيح؟",
    "answer_1": "Activity Selection",
    "answer_2": "Minimum Spanning Tree",
    "answer_3": "0/1 Knapsack",
    "answer_4": "Dijkstra",
    "correct_ans": "0/1 Knapsack"
  },

  {
    "title": "لماذا لا تعمل Dijkstra مع الأوزان السالبة؟",
    "answer_1": "لأنها تستخدم Heap",
    "answer_2": "لأنها تفترض أن المسار الأقصر لا يتغير",
    "answer_3": "لأنها بطيئة",
    "answer_4": "لأنها تحتاج DFS",
    "correct_ans": "لأنها تفترض أن المسار الأقصر لا يتغير"
  },
  {
    "title": "أي خوارزمية تستخدم لإيجاد أقصر مسار مع أوزان سالبة؟",
    "answer_1": "Dijkstra",
    "answer_2": "Prim",
    "answer_3": "Bellman-Ford",
    "answer_4": "BFS",
    "correct_ans": "Bellman-Ford"
  },

  {
    "title": "ما الفرق الأساسي بين BFS و Dijkstra؟",
    "answer_1": "BFS أبطأ",
    "answer_2": "BFS يعمل فقط مع أوزان متساوية",
    "answer_3": "Dijkstra لا يستخدم Queue",
    "answer_4": "لا يوجد فرق",
    "correct_ans": "BFS يعمل فقط مع أوزان متساوية"
  },
  {
    "title": "متى يكون BFS كافيًا لإيجاد أقصر مسار؟",
    "answer_1": "عندما تكون الأوزان موجبة",
    "answer_2": "عندما تكون الأوزان متساوية",
    "answer_3": "عندما يكون المخطط غير متصل",
    "answer_4": "عندما يكون المخطط موجهًا",
    "correct_ans": "عندما تكون الأوزان متساوية"
  },
  {
    "title": "ما الفرق بين O(n) و O(n^2) من حيث النمو؟",
    "answer_1": "O(n) ينمو أبطأ من O(n^2)",
    "answer_2": "O(n^2) ينمو أبطأ من O(n)",
    "answer_3": "كلاهما متساويان",
    "answer_4": "يعتمدان على اللغة",
    "correct_ans": "O(n) ينمو أبطأ من O(n^2)"
  },
  {
    "title": "أي تعقيد يُعد أفضل من حيث الكفاءة مع زيادة حجم المدخلات؟",
    "answer_1": "O(n^2)",
    "answer_2": "O(n log n)",
    "answer_3": "O(n)",
    "answer_4": "O(2^n)",
    "correct_ans": "O(n)"
  },
  {
    "title": "لماذا نهمل الثوابت في Big-O؟",
    "answer_1": "لأنها غير مهمة عمليًا",
    "answer_2": "لأنها لا تؤثر على سلوك النمو",
    "answer_3": "لأنها تعتمد على اللغة",
    "answer_4": "لأنها صفر دائمًا",
    "correct_ans": "لأنها لا تؤثر على سلوك النمو"
  },
  {
    "title": "أي خوارزمية يكون Best Case لها O(n)؟",
    "answer_1": "Binary Search",
    "answer_2": "Bubble Sort مع تحسين",
    "answer_3": "Merge Sort",
    "answer_4": "Quick Sort دائمًا",
    "correct_ans": "Bubble Sort مع تحسين"
  },
  {
    "title": "متى يكون Binary Search غير صالح للاستخدام؟",
    "answer_1": "عندما تكون البيانات كبيرة",
    "answer_2": "عندما تكون البيانات غير مرتبة",
    "answer_3": "عندما تكون البيانات عددية",
    "answer_4": "عندما يكون n صغير",
    "correct_ans": "عندما تكون البيانات غير مرتبة"
  },

  {
    "title": "ما الغاية من استخدام Recursion؟",
    "answer_1": "تقليل الذاكرة",
    "answer_2": "تبسيط حل المشاكل المتكررة",
    "answer_3": "تسريع التنفيذ دائمًا",
    "answer_4": "إلغاء Stack",
    "correct_ans": "تبسيط حل المشاكل المتكررة"
  },
  {
    "title": "أي عنصر ضروري في أي خوارزمية Recursion؟",
    "answer_1": "Loop",
    "answer_2": "Base Case",
    "answer_3": "Queue",
    "answer_4": "Array",
    "correct_ans": "Base Case"
  },
  {
    "title": "متى يكون الحل التكراري Iterative أفضل من Recursion؟",
    "answer_1": "عندما يكون عمق الاستدعاء كبير",
    "answer_2": "عندما يكون الكود أطول",
    "answer_3": "عندما نستخدم DP",
    "answer_4": "دائمًا",
    "correct_ans": "عندما يكون عمق الاستدعاء كبير"
  },

  {
    "title": "لماذا نستخدم Master Theorem؟",
    "answer_1": "لتحليل Hashing",
    "answer_2": "لحل علاقات العودية",
    "answer_3": "لتحليل Greedy",
    "answer_4": "لتحليل Graphs",
    "correct_ans": "لحل علاقات العودية"
  },
  {
    "title": "إذا كانت T(n)=3T(n/2)+n فإن التعقيد هو:",
    "answer_1": "O(n)",
    "answer_2": "O(n log n)",
    "answer_3": "O(n^2)",
    "answer_4": "O(n^{log2 3})",
    "correct_ans": "O(n^{log2 3})"
  },

  {
    "title": "أي بنية بيانات ضرورية لتنفيذ Heap؟",
    "answer_1": "Stack",
    "answer_2": "Queue",
    "answer_3": "Array",
    "answer_4": "Linked List",
    "correct_ans": "Array"
  },
  {
    "title": "في Heap، أي عملية هي الأسرع؟",
    "answer_1": "إدخال عنصر",
    "answer_2": "حذف الجذر",
    "answer_3": "الوصول إلى الجذر",
    "answer_4": "إعادة البناء",
    "correct_ans": "الوصول إلى الجذر"
  },
  {
    "title": "لماذا Heap Sort غير مستقر؟",
    "answer_1": "لأنه يستخدم Heap",
    "answer_2": "لأن ترتيب العناصر المتساوية قد يتغير",
    "answer_3": "لأنه بطيء",
    "answer_4": "لأنه لا يستخدم recursion",
    "correct_ans": "لأن ترتيب العناصر المتساوية قد يتغير"
  },

  {
    "title": "ما الهدف الأساسي من Hash Function الجيدة؟",
    "answer_1": "تقليل الذاكرة",
    "answer_2": "توزيع المفاتيح بشكل متجانس",
    "answer_3": "منع التصادم نهائيًا",
    "answer_4": "زيادة السرعة فقط",
    "correct_ans": "توزيع المفاتيح بشكل متجانس"
  },
  {
    "title": "أي طريقة Collision Handling تستخدم مؤشرًا ثانيًا؟",
    "answer_1": "Chaining",
    "answer_2": "Linear Probing",
    "answer_3": "Double Hashing",
    "answer_4": "DFS",
    "correct_ans": "Double Hashing"
  },

  {
    "title": "أي خاصية يجب توفرها لتطبيق Greedy Algorithm؟",
    "answer_1": "Overlapping Subproblems",
    "answer_2": "Greedy Choice Property",
    "answer_3": "Memoization",
    "answer_4": "Recursion",
    "correct_ans": "Greedy Choice Property"
  },
  {
    "title": "أي مشكلة تُحل بـ Greedy ولكن لا تُحل بـ Dynamic Programming؟",
    "answer_1": "0/1 Knapsack",
    "answer_2": "Activity Selection",
    "answer_3": "Fibonacci",
    "answer_4": "All-Pairs Shortest Path",
    "correct_ans": "Activity Selection"
  },

  {
    "title": "متى نستخدم Dynamic Programming بدل Recursion؟",
    "answer_1": "عندما لا توجد مشاكل جزئية",
    "answer_2": "عندما تتكرر نفس الحسابات",
    "answer_3": "عندما تكون المدخلات صغيرة",
    "answer_4": "عندما نستخدم Graph",
    "correct_ans": "عندما تتكرر نفس الحسابات"
  },
  {
    "title": "ما الفرق بين Memoization و Tabulation؟",
    "answer_1": "لا فرق",
    "answer_2": "Memoization من الأعلى للأسفل",
    "answer_3": "Tabulation لا يستخدم ذاكرة",
    "answer_4": "Memoization أبطأ دائمًا",
    "correct_ans": "Memoization من الأعلى للأسفل"
  },

  {
    "title": "أي خوارزمية تستخدم لإيجاد أقصر مسار من عقدة واحدة؟",
    "answer_1": "Floyd-Warshall",
    "answer_2": "Prim",
    "answer_3": "Dijkstra",
    "answer_4": "Kruskal",
    "correct_ans": "Dijkstra"
  },
  {
    "title": "لماذا Bellman-Ford أبطأ من Dijkstra؟",
    "answer_1": "لأنه يستخدم Graph أكبر",
    "answer_2": "لأنه يعالج الأوزان السالبة",
    "answer_3": "لأنه لا يستخدم Heap",
    "answer_4": "لأنه تكراري",
    "correct_ans": "لأنه يعالج الأوزان السالبة"
  },
  {
    "title": "أي خوارزمية تكتشف الدورات السالبة؟",
    "answer_1": "Dijkstra",
    "answer_2": "BFS",
    "answer_3": "Bellman-Ford",
    "answer_4": "DFS",
    "correct_ans": "Bellman-Ford"
  },
  {
    "title": "ما السبب في أن التعقيد الزمني هو معيار أهم من عدد الأسطر البرمجية؟",
    "answer_1": "لأن عدد الأسطر لا يعكس أداء الخوارزمية",
    "answer_2": "لأن عدد الأسطر ثابت دائمًا",
    "answer_3": "لأن عدد الأسطر يعتمد على اللغة فقط",
    "answer_4": "لأن عدد الأسطر يحدد الذاكرة",
    "correct_ans": "لأن عدد الأسطر لا يعكس أداء الخوارزمية"
  },
  {
    "title": "أي حالة من الحالات التالية لا تؤخذ عادةً بعين الاعتبار عند تحليل الأداء؟",
    "answer_1": "Best Case",
    "answer_2": "Worst Case",
    "answer_3": "Average Case",
    "answer_4": "Random Case",
    "correct_ans": "Random Case"
  },
  {
    "title": "لماذا يُعتبر Worst Case أكثر الحالات استخدامًا في التحليل؟",
    "answer_1": "لأنه أسهل حسابًا",
    "answer_2": "لأنه يعطي ضمانًا للأداء",
    "answer_3": "لأنه أسرع حالة",
    "answer_4": "لأنه يعتمد على البيانات",
    "correct_ans": "لأنه يعطي ضمانًا للأداء"
  },

  {
    "title": "ما التأثير الأساسي لزيادة عمق الاستدعاء التراجعي؟",
    "answer_1": "زيادة الزمن فقط",
    "answer_2": "زيادة استخدام Stack",
    "answer_3": "تقليل الذاكرة",
    "answer_4": "تحسين الأداء",
    "correct_ans": "زيادة استخدام Stack"
  },
  {
    "title": "أي من التالي يُعد مثالًا على مشكلة تراجعية طبيعية؟",
    "answer_1": "فرز مصفوفة",
    "answer_2": "حساب المضروب (Factorial)",
    "answer_3": "البحث الخطي",
    "answer_4": "الطباعة",
    "correct_ans": "حساب المضروب (Factorial)"
  },
  {
    "title": "متى يصبح استخدام Recursion غير عملي؟",
    "answer_1": "عندما تكون المشكلة بسيطة",
    "answer_2": "عندما يكون عدد الاستدعاءات كبيرًا جدًا",
    "answer_3": "عندما يكون الحل واضحًا",
    "answer_4": "عندما نستخدم DP",
    "correct_ans": "عندما يكون عدد الاستدعاءات كبيرًا جدًا"
  },

  {
    "title": "أي خاصية يجب تحققها قبل تطبيق Divide and Conquer؟",
    "answer_1": "تداخل المشاكل الجزئية",
    "answer_2": "إمكانية تقسيم المشكلة لمشاكل مستقلة",
    "answer_3": "Greedy Choice",
    "answer_4": "استخدام Heap",
    "correct_ans": "إمكانية تقسيم المشكلة لمشاكل مستقلة"
  },
  {
    "title": "لماذا لا تُعتبر كل الخوارزميات التراجعية Divide and Conquer؟",
    "answer_1": "لأنها لا تستخدم Stack",
    "answer_2": "لأن المشاكل الجزئية قد تكون غير مستقلة",
    "answer_3": "لأنها بطيئة",
    "answer_4": "لأنها لا تحتوي Base Case",
    "correct_ans": "لأن المشاكل الجزئية قد تكون غير مستقلة"
  },

  {
    "title": "أي عملية في Heap تحتاج إلى إعادة ترتيب من الأعلى للأسفل؟",
    "answer_1": "إدخال عنصر",
    "answer_2": "الوصول إلى الجذر",
    "answer_3": "حذف الجذر",
    "answer_4": "بناء Heap",
    "correct_ans": "حذف الجذر"
  },
  {
    "title": "لماذا يُستخدم Heap بدل المصفوفة المرتبة في Priority Queue؟",
    "answer_1": "لأنه أسهل تنفيذًا",
    "answer_2": "لأن الإدخال والحذف أسرع",
    "answer_3": "لأنه يستهلك ذاكرة أقل",
    "answer_4": "لأنه يحافظ على الترتيب الكامل",
    "correct_ans": "لأن الإدخال والحذف أسرع"
  },

  {
    "title": "أي عامل يؤثر أكثر على أداء Hash Table؟",
    "answer_1": "حجم الذاكرة فقط",
    "answer_2": "دالة التجزئة",
    "answer_3": "عدد المتغيرات",
    "answer_4": "نوع اللغة",
    "correct_ans": "دالة التجزئة"
  },
  {
    "title": "لماذا يُعاد Resize لجدول التجزئة؟",
    "answer_1": "لتقليل الذاكرة",
    "answer_2": "لتقليل عدد التصادمات",
    "answer_3": "لزيادة عدد المفاتيح",
    "answer_4": "لتغيير الدالة",
    "correct_ans": "لتقليل عدد التصادمات"
  },

  {
    "title": "أي خاصية تربط بين Greedy و Dynamic Programming؟",
    "answer_1": "استخدام الذاكرة",
    "answer_2": "Optimal Substructure",
    "answer_3": "Recursion",
    "answer_4": "Stack",
    "correct_ans": "Optimal Substructure"
  },
  {
    "title": "لماذا لا تُعتبر Greedy مناسبة لكل المشاكل؟",
    "answer_1": "لأنها بطيئة",
    "answer_2": "لأن الحل المحلي قد لا يؤدي للحل الأمثل",
    "answer_3": "لأنها معقدة",
    "answer_4": "لأنها تحتاج ذاكرة",
    "correct_ans": "لأن الحل المحلي قد لا يؤدي للحل الأمثل"
  },

  {
    "title": "متى يكون استخدام Dynamic Programming غير مبرر؟",
    "answer_1": "عندما لا توجد مشاكل جزئية متكررة",
    "answer_2": "عندما تكون المشكلة كبيرة",
    "answer_3": "عندما نستخدم Graph",
    "answer_4": "عندما نحتاج حل أمثل",
    "correct_ans": "عندما لا توجد مشاكل جزئية متكررة"
  },
  {
    "title": "أي مشكلة لا تحتوي Overlapping Subproblems؟",
    "answer_1": "Fibonacci",
    "answer_2": "Binary Search",
    "answer_3": "0/1 Knapsack",
    "answer_4": "LCS",
    "correct_ans": "Binary Search"
  },

  {
    "title": "لماذا تُستخدم Priority Queue في Dijkstra؟",
    "answer_1": "لتخزين جميع العقد",
    "answer_2": "لاختيار العقدة ذات أقل مسافة مؤقتة",
    "answer_3": "لتقليل عدد الرؤوس",
    "answer_4": "لتنفيذ BFS",
    "correct_ans": "لاختيار العقدة ذات أقل مسافة مؤقتة"
  },
  {
    "title": "أي تغيير بسيط يجعل BFS يعادل Dijkstra؟",
    "answer_1": "استخدام Stack",
    "answer_2": "إزالة Priority Queue",
    "answer_3": "جعل جميع الأوزان متساوية",
    "answer_4": "جعل المخطط غير متصل",
    "correct_ans": "جعل جميع الأوزان متساوية"
  },
  {
    "title": "ما المقصود بمفهوم Lower Bound في تحليل الخوارزميات؟",
    "answer_1": "أفضل زمن تنفيذ",
    "answer_2": "أقل زمن ممكن لأي خوارزمية لحل المشكلة",
    "answer_3": "الزمن الوسطي",
    "answer_4": "الزمن الفعلي",
    "correct_ans": "أقل زمن ممكن لأي خوارزمية لحل المشكلة"
  },
  {
    "title": "متى نستخدم Omega Notation؟",
    "answer_1": "لتمثيل الحد العلوي",
    "answer_2": "لتمثيل الحد السفلي",
    "answer_3": "لتمثيل الحالة المتوسطة",
    "answer_4": "لتمثيل الزمن الحقيقي",
    "correct_ans": "لتمثيل الحد السفلي"
  },
  {
    "title": "أي تعبير يمثل حدًا علويًا وحدًا سفليًا في نفس الوقت؟",
    "answer_1": "Big-O",
    "answer_2": "Omega",
    "answer_3": "Theta",
    "answer_4": "Sigma",
    "correct_ans": "Theta"
  },

  {
    "title": "لماذا لا يمكن تحسين بعض الخوارزميات عن حد معين؟",
    "answer_1": "بسبب ضعف العتاد",
    "answer_2": "بسبب وجود Lower Bound للمشكلة",
    "answer_3": "بسبب لغة البرمجة",
    "answer_4": "بسبب حجم الذاكرة",
    "correct_ans": "بسبب وجود Lower Bound للمشكلة"
  },
  {
    "title": "أي مشكلة تمتلك Lower Bound يساوي O(n log n)؟",
    "answer_1": "البحث الخطي",
    "answer_2": "الفرز بالمقارنة",
    "answer_3": "Binary Search",
    "answer_4": "BFS",
    "correct_ans": "الفرز بالمقارنة"
  },

  {
    "title": "ما الهدف من تحليل Average Case؟",
    "answer_1": "إعطاء أسوأ احتمال",
    "answer_2": "تمثيل الأداء المتوقع غالبًا",
    "answer_3": "ضمان الأداء",
    "answer_4": "قياس الذاكرة",
    "correct_ans": "تمثيل الأداء المتوقع غالبًا"
  },
  {
    "title": "لماذا يُهمل Average Case أحيانًا في التحليل؟",
    "answer_1": "لأنه غير دقيق",
    "answer_2": "لأنه يتطلب افتراض توزيع للمدخلات",
    "answer_3": "لأنه بطيء",
    "answer_4": "لأنه يعتمد على اللغة",
    "correct_ans": "لأنه يتطلب افتراض توزيع للمدخلات"
  },

  {
    "title": "ما المقصود بمفهوم Decision Tree في تحليل الخوارزميات؟",
    "answer_1": "شجرة بحث ثنائية",
    "answer_2": "نموذج لتمثيل جميع المقارنات الممكنة",
    "answer_3": "شجرة Heap",
    "answer_4": "شجرة DFS",
    "correct_ans": "نموذج لتمثيل جميع المقارنات الممكنة"
  },
  {
    "title": "يُستخدم Decision Tree غالبًا لإثبات:",
    "answer_1": "Best Case",
    "answer_2": "Average Case",
    "answer_3": "Lower Bound",
    "answer_4": "Space Complexity",
    "correct_ans": "Lower Bound"
  },

  {
    "title": "لماذا لا يمكن لأي خوارزمية مقارنة أن تعمل بزمن O(n) في أسوأ حالة؟",
    "answer_1": "بسبب حجم الذاكرة",
    "answer_2": "بسبب عدد المقارنات المطلوب",
    "answer_3": "بسبب Stack",
    "answer_4": "بسبب Hashing",
    "correct_ans": "بسبب عدد المقارنات المطلوب"
  },

  {
    "title": "أي نوع من الخوارزميات لا يتقيد بـ Lower Bound للفرز بالمقارنة؟",
    "answer_1": "Merge Sort",
    "answer_2": "Quick Sort",
    "answer_3": "Heap Sort",
    "answer_4": "Counting Sort",
    "correct_ans": "Counting Sort"
  },
  {
    "title": "لماذا لا يُعد Counting Sort خوارزمية مقارنة؟",
    "answer_1": "لأنه يستخدم الذاكرة",
    "answer_2": "لأنه لا يقارن بين العناصر مباشرة",
    "answer_3": "لأنه بطيء",
    "answer_4": "لأنه غير مستقر",
    "correct_ans": "لأنه لا يقارن بين العناصر مباشرة"
  },

  {
    "title": "ما الشرط الأساسي لاستخدام Counting Sort؟",
    "answer_1": "أن تكون البيانات مرتبة",
    "answer_2": "أن يكون مجال القيم محدودًا",
    "answer_3": "أن تكون البيانات سالبة",
    "answer_4": "أن تكون البيانات نصية",
    "correct_ans": "أن يكون مجال القيم محدودًا"
  },

  {
    "title": "أي خوارزمية تعتمد على Counting Sort كجزء منها؟",
    "answer_1": "Merge Sort",
    "answer_2": "Heap Sort",
    "answer_3": "Radix Sort",
    "answer_4": "Quick Sort",
    "correct_ans": "Radix Sort"
  },

  {
    "title": "لماذا يُعد Radix Sort مستقرًا؟",
    "answer_1": "لأنه يستخدم Recursion",
    "answer_2": "لأنه يعتمد على خوارزمية مستقرة في كل مرحلة",
    "answer_3": "لأنه لا يستخدم مقارنات",
    "answer_4": "لأنه سريع",
    "correct_ans": "لأنه يعتمد على خوارزمية مستقرة في كل مرحلة"
  },

  {
    "title": "ما التعقيد الزمني لـ Radix Sort عندما يكون عدد الخانات ثابتًا؟",
    "answer_1": "O(n log n)",
    "answer_2": "O(n)",
    "answer_3": "O(n^2)",
    "answer_4": "O(log n)",
    "correct_ans": "O(n)"
  },
  {
    "title": "ما الفرق بين Upper Bound و Lower Bound في تحليل الخوارزميات؟",
    "answer_1": "Upper Bound يمثل أسوأ أداء و Lower Bound يمثل أفضل أداء ممكن",
    "answer_2": "Upper Bound يمثل الأداء الحقيقي",
    "answer_3": "Lower Bound يمثل متوسط الأداء",
    "answer_4": "لا يوجد فرق بينهما",
    "correct_ans": "Upper Bound يمثل أسوأ أداء و Lower Bound يمثل أفضل أداء ممكن"
  },
  {
    "title": "أي ترميز يُستخدم لتمثيل الحد الأدنى لأداء أي خوارزمية؟",
    "answer_1": "Big-O",
    "answer_2": "Theta",
    "answer_3": "Omega",
    "answer_4": "Sigma",
    "correct_ans": "Omega"
  },
  {
    "title": "متى نقول إن خوارزمية ما Optimal؟",
    "answer_1": "عندما تعمل بأسرع زمن على جهاز معين",
    "answer_2": "عندما تحقق Lower Bound للمشكلة",
    "answer_3": "عندما تكون سهلة التنفيذ",
    "answer_4": "عندما تستهلك ذاكرة قليلة",
    "correct_ans": "عندما تحقق Lower Bound للمشكلة"
  },

  {
    "title": "لماذا يُستخدم نموذج Decision Tree في تحليل الفرز؟",
    "answer_1": "لتمثيل بنية الشجرة فقط",
    "answer_2": "لحساب عدد المقارنات الممكنة",
    "answer_3": "لتحليل الذاكرة",
    "answer_4": "لتمثيل Heap",
    "correct_ans": "لحساب عدد المقارنات الممكنة"
  },
  {
    "title": "ارتفاع Decision Tree في خوارزميات الفرز يمثل:",
    "answer_1": "عدد العناصر",
    "answer_2": "عدد المقارنات في أسوأ حالة",
    "answer_3": "عدد التبديلات",
    "answer_4": "عدد الخانات",
    "correct_ans": "عدد المقارنات في أسوأ حالة"
  },

  {
    "title": "أي عبارة صحيحة حول Comparison Sort؟",
    "answer_1": "يمكن أن يعمل بزمن O(n)",
    "answer_2": "لا يمكن أن يتجاوز Lower Bound يساوي O(n log n)",
    "answer_3": "لا يستخدم المقارنات",
    "answer_4": "لا يعتمد على Decision Tree",
    "correct_ans": "لا يمكن أن يتجاوز Lower Bound يساوي O(n log n)"
  },

  {
    "title": "لماذا لا تعتمد Counting Sort على المقارنة؟",
    "answer_1": "لأنها لا تقارن القيم مباشرة",
    "answer_2": "لأنها بطيئة",
    "answer_3": "لأنها غير مستقرة",
    "answer_4": "لأنها تستخدم Recursion",
    "correct_ans": "لأنها لا تقارن القيم مباشرة"
  },
  {
    "title": "ما العامل الأكثر تأثيرًا على أداء Counting Sort؟",
    "answer_1": "عدد العناصر n",
    "answer_2": "عدد الخانات",
    "answer_3": "مدى القيم k",
    "answer_4": "ترتيب البيانات",
    "correct_ans": "مدى القيم k"
  },

  {
    "title": "لماذا يجب أن تكون الخوارزمية المستخدمة في Radix Sort مستقرة؟",
    "answer_1": "لتحسين السرعة",
    "answer_2": "للحفاظ على ترتيب الخانات السابقة",
    "answer_3": "لتقليل الذاكرة",
    "answer_4": "لمنع التصادم",
    "correct_ans": "للحفاظ على ترتيب الخانات السابقة"
  },
  {
    "title": "أي عامل يؤثر على تعقيد Radix Sort؟",
    "answer_1": "عدد العناصر فقط",
    "answer_2": "عدد الخانات في الأعداد",
    "answer_3": "نوع البيانات",
    "answer_4": "لغة البرمجة",
    "correct_ans": "عدد الخانات في الأعداد"
  },

  {
    "title": "متى تكون Non-comparison Sort أفضل من Comparison Sort؟",
    "answer_1": "عندما يكون عدد العناصر صغيرًا",
    "answer_2": "عندما يكون مجال القيم محدودًا",
    "answer_3": "عندما تكون البيانات مرتبة",
    "answer_4": "عندما تكون البيانات عشوائية",
    "correct_ans": "عندما يكون مجال القيم محدودًا"
  },

  {
    "title": "أي خوارزمية لا تتأثر بالترتيب الابتدائي للبيانات؟",
    "answer_1": "Insertion Sort",
    "answer_2": "Bubble Sort",
    "answer_3": "Merge Sort",
    "answer_4": "Quick Sort",
    "correct_ans": "Merge Sort"
  },

  {
    "title": "لماذا لا يُعد Radix Sort مناسبًا لكل أنواع البيانات؟",
    "answer_1": "لأنه بطيء",
    "answer_2": "لأنه يتطلب تمثيل رقمي",
    "answer_3": "لأنه غير مستقر",
    "answer_4": "لأنه يحتاج Recursion",
    "correct_ans": "لأنه يتطلب تمثيل رقمي"
  },

  {
    "title": "أي من التالي يُعد شرطًا أساسيًا لتحسين أداء الفرز؟",
    "answer_1": "زيادة الذاكرة",
    "answer_2": "معرفة طبيعة البيانات",
    "answer_3": "استخدام Recursion",
    "answer_4": "زيادة عدد المقارنات",
    "correct_ans": "معرفة طبيعة البيانات"
  },
  {
    "title": "لماذا لا يمكن إثبات Lower Bound للفرز بالمقارنة باستخدام Big-O فقط؟",
    "answer_1": "لأن Big-O يمثل حدًا علويًا فقط",
    "answer_2": "لأن Big-O يعتمد على اللغة",
    "answer_3": "لأن Big-O يمثل الزمن الحقيقي",
    "answer_4": "لأن Big-O يمثل الحالة المتوسطة",
    "correct_ans": "لأن Big-O يمثل حدًا علويًا فقط"
  },
  {
    "title": "أي ترميز يُستخدم لإثبات أن خوارزمية لا يمكن تحسينها أكثر؟",
    "answer_1": "Big-O",
    "answer_2": "Theta",
    "answer_3": "Omega",
    "answer_4": "Sigma",
    "correct_ans": "Omega"
  },
  {
    "title": "متى نقول إن خوارزمية ما Optimal بالنسبة لمشكلة معينة؟",
    "answer_1": "عندما تكون الأسرع عمليًا",
    "answer_2": "عندما تحقق Lower Bound للمشكلة",
    "answer_3": "عندما تعمل بزمن Theta",
    "answer_4": "عندما لا تستخدم Recursion",
    "correct_ans": "عندما تحقق Lower Bound للمشكلة"
  },

  {
    "title": "ما العلاقة بين عدد الأوراق في Decision Tree وعدد المدخلات الممكنة؟",
    "answer_1": "عدد الأوراق يساوي عدد العناصر",
    "answer_2": "عدد الأوراق ≥ عدد التبديلات الممكنة",
    "answer_3": "عدد الأوراق ≥ عدد الترتيبات الممكنة للعناصر",
    "answer_4": "عدد الأوراق لا علاقة له بالمدخلات",
    "correct_ans": "عدد الأوراق ≥ عدد الترتيبات الممكنة للعناصر"
  },
  {
    "title": "لماذا يُستخدم log2 في حساب ارتفاع Decision Tree؟",
    "answer_1": "لأن الشجرة ثنائية",
    "answer_2": "لأن عدد المقارنات خطي",
    "answer_3": "لأن المدخلات ثنائية",
    "answer_4": "لأن الزمن ثابت",
    "correct_ans": "لأن الشجرة ثنائية"
  },

  {
    "title": "أي فرضية أساسية يُبنى عليها Lower Bound للفرز بالمقارنة؟",
    "answer_1": "أن العناصر أعداد صحيحة",
    "answer_2": "أن كل مقارنة تعطي نتيجتين فقط",
    "answer_3": "أن الخوارزمية تراجعية",
    "answer_4": "أن البيانات مرتبة جزئيًا",
    "correct_ans": "أن كل مقارنة تعطي نتيجتين فقط"
  },

  {
    "title": "لماذا لا يخضع Counting Sort لـ Lower Bound الخاص بالفرز بالمقارنة؟",
    "answer_1": "لأنه أسرع",
    "answer_2": "لأنه لا يستخدم المقارنة بين العناصر",
    "answer_3": "لأنه غير مستقر",
    "answer_4": "لأنه يعتمد على Recursion",
    "correct_ans": "لأنه لا يستخدم المقارنة بين العناصر"
  },
  {
    "title": "أي تغيير يجعل Counting Sort غير عملي؟",
    "answer_1": "زيادة عدد العناصر n",
    "answer_2": "زيادة مدى القيم k بشكل كبير",
    "answer_3": "ترتيب البيانات",
    "answer_4": "وجود قيم مكررة",
    "correct_ans": "زيادة مدى القيم k بشكل كبير"
  },

  {
    "title": "لماذا لا يمكن استخدام Counting Sort مباشرة مع الأعداد الحقيقية؟",
    "answer_1": "لأنها سالبة",
    "answer_2": "لأن مجال القيم غير محدود",
    "answer_3": "لأنها غير مستقرة",
    "answer_4": "لأنها بطيئة",
    "correct_ans": "لأن مجال القيم غير محدود"
  },

  {
    "title": "في Radix Sort، ماذا يحدث إذا استُخدمت خوارزمية غير مستقرة في إحدى المراحل؟",
    "answer_1": "يبقى الترتيب صحيحًا",
    "answer_2": "يزداد الزمن فقط",
    "answer_3": "يفشل الترتيب النهائي",
    "answer_4": "يزداد استهلاك الذاكرة",
    "correct_ans": "يفشل الترتيب النهائي"
  },
  {
    "title": "أي عامل لا يؤثر على التعقيد الزمني لـ Radix Sort؟",
    "answer_1": "عدد العناصر n",
    "answer_2": "عدد الخانات",
    "answer_3": "مدى القيم",
    "answer_4": "عدد المراحل",
    "correct_ans": "مدى القيم"
  },

  {
    "title": "لماذا لا يُعد Radix Sort خوارزمية مقارنة؟",
    "answer_1": "لأنه بطيء",
    "answer_2": "لأنه لا يقارن بين عنصرين مباشرة",
    "answer_3": "لأنه غير مستقر",
    "answer_4": "لأنه يعتمد على Heap",
    "correct_ans": "لأنه لا يقارن بين عنصرين مباشرة"
  },

  {
    "title": "أي سيناريو يجعل Merge Sort غير خيار جيد رغم تعقيده الممتاز؟",
    "answer_1": "عندما تكون البيانات عشوائية",
    "answer_2": "عندما تكون الذاكرة محدودة",
    "answer_3": "عندما يكون n كبيرًا",
    "answer_4": "عندما نحتاج ترتيبًا مستقرًا",
    "correct_ans": "عندما تكون الذاكرة محدودة"
  },

  {
    "title": "أي عبارة صحيحة حول Theta Notation؟",
    "answer_1": "تمثل حدًا علويًا فقط",
    "answer_2": "تمثل حدًا سفليًا فقط",
    "answer_3": "تمثل حدًا علويًا وسفليًا معًا",
    "answer_4": "تمثل الزمن الحقيقي دائمًا",
    "correct_ans": "تمثل حدًا علويًا وسفليًا معًا"
  }
]