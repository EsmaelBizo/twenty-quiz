[
  {
    "title": "أي مما يلي لا يمكن أن يكون نتيجة مباشرة لعملية Partitioning واحدة؟",
    "answer_1": "وجود عناصر أصغر من المحور في جهة واحدة",
    "answer_2": "وجود عناصر أكبر من المحور في الجهة المقابلة",
    "answer_3": "ترتيب كامل لجميع عناصر المصفوفة",
    "answer_4": "تحديد نقطة فصل بين قسمين",
    "correct_ans": "ترتيب كامل لجميع عناصر المصفوفة"
  },
  {
    "title": "لماذا تُطبّق QuickSort تراجعيًا على الأقسام الناتجة بعد Partitioning؟",
    "answer_1": "لأن العناصر أصبحت عشوائية",
    "answer_2": "لأن كل قسم يمثل مشكلة أصغر من نفس النوع",
    "answer_3": "لأن المحور قد يتغير",
    "answer_4": "لأن المصفوفة لم تعد صالحة",
    "correct_ans": "لأن كل قسم يمثل مشكلة أصغر من نفس النوع"
  },
  {
    "title": "في حال تم اختيار محور غير مناسب بشكل متكرر، ما الأثر المتوقع على تنفيذ QuickSort؟",
    "answer_1": "توقف الخوارزمية",
    "answer_2": "زيادة عدد خطوات التقسيم والاستدعاء",
    "answer_3": "الحصول على ترتيب خاطئ",
    "answer_4": "عدم تنفيذ Partitioning",
    "correct_ans": "زيادة عدد خطوات التقسيم والاستدعاء"
  },
  {
    "title": "متى نعتبر أن QuickSort أنهى ترتيب المصفوفة بالكامل؟",
    "answer_1": "بعد تنفيذ أول Partitioning",
    "answer_2": "بعد ترتيب جميع الأقسام الناتجة",
    "answer_3": "عند اختيار محور مناسب",
    "answer_4": "عند تساوي جميع العناصر",
    "correct_ans": "بعد ترتيب جميع الأقسام الناتجة"
  },
  {
    "title": "ما الهدف الأساسي من خوارزمية MergeSort؟",
    "answer_1": "تقليل عدد العناصر",
    "answer_2": "ترتيب العناصر",
    "answer_3": "البحث عن عنصر محدد",
    "answer_4": "دمج مصفوفتين",
    "correct_ans": "ترتيب العناصر"
  },
  {
    "title": "ما النتيجة المباشرة لعملية Partitioning في QuickSort؟",
    "answer_1": "ترتيب كامل للمصفوفة",
    "answer_2": "تقسيم العناصر إلى قسمين بالنسبة لمحور",
    "answer_3": "اختيار أصغر عنصر",
    "answer_4": "إلغاء الاستدعاء التراجعي",
    "correct_ans": "تقسيم العناصر إلى قسمين بالنسبة لمحور"
  },
  {
    "title": "أي حالة تجعل QuickSort يتوقف عن الاستدعاء التراجعي؟",
    "answer_1": "عند تساوي جميع العناصر",
    "answer_2": "عندما يصبح القسم بطول صفر أو واحد",
    "answer_3": "عند اختيار محور جيد",
    "answer_4": "بعد أول تقسيم",
    "correct_ans": "عندما يصبح القسم بطول صفر أو واحد"
  },
  {
    "title": "أي ميزة لـ QuickSort تميزها عن MergeSort؟",
    "answer_1": "لا يستخدم recursion",
    "answer_2": "لا يحتاج خطوة دمج",
    "answer_3": "أبطأ دائمًا",
    "answer_4": "يستخدم ذاكرة إضافية",
    "correct_ans": "لا يحتاج خطوة دمج"
  },
  {
    "title": "ما الهدف من استخدام مؤشرين يتحركان من جهتين متعاكستين في خوارزمية QuickSort؟",
    "answer_1": "لتقليل عدد العناصر",
    "answer_2": "لتقسيم العناصر بالنسبة للمحور",
    "answer_3": "لتسريع الاستدعاء التراجعي",
    "answer_4": "لتفادي استخدام recursion",
    "correct_ans": "لتقسيم العناصر بالنسبة للمحور"
  },
  {
    "title": "في عملية البحث عن قيمة داخل BST باستخدام حلقة while، متى تتوقف الحلقة؟",
    "answer_1": "عند الوصول إلى عقدة ورقية فقط",
    "answer_2": "عند العثور على القيمة أو الوصول إلى NULL",
    "answer_3": "عند مقارنة أول عقدة فقط",
    "answer_4": "عند الانتقال إلى الفرع الأيمن",
    "correct_ans": "عند العثور على القيمة أو الوصول إلى NULL"
  },
  {
    "title": "ما نتيجة تنفيذ العبور من نوع Inorder على Binary Search Tree؟",
    "answer_1": "عناصر مرتبة تنازليًا",
    "answer_2": "عناصر مرتبة تصاعديًا",
    "answer_3": "العناصر حسب الإدخال",
    "answer_4": "العناصر بشكل عشوائي",
    "correct_ans": "عناصر مرتبة تصاعديًا"
  },
  {
    "title": "أي نوع العبور يزور العقدة قبل أبنائها في BST؟",
    "answer_1": "Inorder",
    "answer_2": "Postorder",
    "answer_3": "Preorder",
    "answer_4": "Level Order",
    "correct_ans": "Preorder"
  },
  {
    "title": "في العبور من نوع Postorder، متى تتم زيارة العقدة؟",
    "answer_1": "قبل زيارة الأبناء",
    "answer_2": "بين الابن الأيسر والأيمن",
    "answer_3": "بعد زيارة الأبناء",
    "answer_4": "فقط عند كونها جذر",
    "correct_ans": "بعد زيارة الأبناء"
  },
  {
    "title": "عند حذف عقدة لها ابنان في BST، أي عنصر يُستخدم للاستبدال ؟",
    "answer_1": "أكبر عنصر في الفرع الأيسر",
    "answer_2": "أصغر عنصر في الفرع الأيمن",
    "answer_3": "الجذر دائمًا",
    "answer_4": "أقرب عقدة ورقية",
    "correct_ans": "أصغر عنصر في الفرع الأيمن"
  },
  {
    "title": "ما القيمة الابتدائية للمؤشر المستخدم للبحث عن عقدة داخل BST ؟",
    "answer_1": "NULL",
    "answer_2": "الجذر",
    "answer_3": "أول عقدة مدخلة",
    "answer_4": "الفرع الأيسر",
    "correct_ans": "الجذر"
  },
  {
    "title": "أثناء البحث في BST، ماذا يحدث إذا كانت القيمة المطلوبة أكبر من قيمة العقدة الحالية؟",
    "answer_1": "ننتقل إلى الفرع الأيسر",
    "answer_2": "ننتقل إلى الفرع الأيمن",
    "answer_3": "نعود إلى الجذر",
    "answer_4": "نُنهي البحث مباشرة",
    "correct_ans": "ننتقل إلى الفرع الأيمن"
  },
  {
    "title": "ماذا يعني وصول المؤشر إلى NULL أثناء عملية البحث في BST؟",
    "answer_1": "العقدة موجودة",
    "answer_2": "القيمة غير موجودة في الشجرة",
    "answer_3": "تم الوصول إلى الجذر",
    "answer_4": "يجب إعادة الإدخال",
    "correct_ans": "القيمة غير موجودة في الشجرة"
  },
  {
    "title": "في العبور من نوع Preorder، ما ترتيب الزيارة الصحيح؟",
    "answer_1": "يسار - عقدة - يمين",
    "answer_2": "يسار - يمين - عقدة",
    "answer_3": "عقدة - يسار - يمين",
    "answer_4": "يمين - عقدة - يسار",
    "correct_ans": "عقدة - يسار - يمين"
  },
  {
    "title": "في العبور من نوع Inorder، ما ترتيب الزيارة الصحيح؟",
    "answer_1": "عقدة - يسار - يمين",
    "answer_2": "يسار - عقدة - يمين",
    "answer_3": "يمين - عقدة - يسار",
    "answer_4": "يسار - يمين - عقدة",
    "correct_ans": "يسار - عقدة - يمين"
  },
  {
    "title": "في العبور من نوع Postorder، ما ترتيب الزيارة الصحيح؟",
    "answer_1": "عقدة - يسار - يمين",
    "answer_2": "يسار - عقدة - يمين",
    "answer_3": "يسار - يمين - عقدة",
    "answer_4": "يمين - عقدة - يسار",
    "correct_ans": "يسار - يمين - عقدة"
  },
  {
    "title": "في BST بعد استبدال قيمة عقدة لها ابنان، ما الخطوة التالية في الحذف؟",
    "answer_1": "إنهاء العملية",
    "answer_2": "حذف العقدة البديلة من موقعها الأصلي",
    "answer_3": "إعادة بناء الشجرة كاملة",
    "answer_4": "نقل الجذر",
    "correct_ans": "حذف العقدة البديلة من موقعها الأصلي"
  },
  {
    "title": "في عملية البحث داخل BST، ما دور المؤشر الذي يحتفظ بالعقدة السابقة (الأب) أثناء التنقل؟",
    "answer_1": "تخزين قيمة الجذر",
    "answer_2": "المساعدة في الربط عند الحذف",
    "answer_3": "تحديد نوع العبور",
    "answer_4": "إنهاء البحث",
    "correct_ans": "المساعدة في الربط عند الحذف"
  },
  {
    "title": "في BST في كود الحذف، ماذا يحدث إذا كانت العقدة المراد حذفها ورقية (Leaf)؟",
    "answer_1": "يتم استبدالها بعقدة أخرى",
    "answer_2": "يتم حذفها وجعل مؤشر الأب يشير إلى NULL",
    "answer_3": "يتم تجاهل الحذف",
    "answer_4": "يتم نقلها إلى الجذر",
    "correct_ans": "يتم حذفها وجعل مؤشر الأب يشير إلى NULL"
  },
  {
    "title": "ما النتيجة إذا حاولنا حذف قيمة غير موجودة في BST حسب منطق البحث؟",
    "answer_1": "يتم حذف الجذر",
    "answer_2": "تنتهي العملية دون أي تعديل",
    "answer_3": "يتم إدخال القيمة بدل حذفها",
    "answer_4": "تُعاد بناء الشجرة",
    "correct_ans": "تنتهي العملية دون أي تعديل"
  },
  {
    "title": "في كود الإدخال إلى BST، ماذا يحدث إذا كانت الشجرة فارغة؟",
    "answer_1": "يتم تجاهل الإدخال",
    "answer_2": "تُنشأ عقدة جديدة وتصبح الجذر",
    "answer_3": "يتم الانتقال إلى الفرع الأيسر",
    "answer_4": "يتم تنفيذ العبور",
    "correct_ans": "تُنشأ عقدة جديدة وتصبح الجذر"
  },
  {
    "title": "في كود الإدخال في BST ، لماذا نحتفظ بمؤشر للعقدة السابقة أثناء التنقل؟",
    "answer_1": "لتحديد نوع العبور",
    "answer_2": "لربط العقدة الجديدة في المكان الصحيح",
    "answer_3": "لتحديث قيمة الجذر",
    "answer_4": "لإنهاء العملية",
    "correct_ans": "لربط العقدة الجديدة في المكان الصحيح"
  },
  {
    "title": "في BST إذا كانت القيمة المُدخلة مساوية لقيمة عقدة موجودة، ماذا يحدث ؟",
    "answer_1": "يتم إدخالها في الفرع الأيسر",
    "answer_2": "يتم إدخالها في الفرع الأيمن",
    "answer_3": "لا يتم الإدخال",
    "answer_4": "يتم استبدال العقدة القديمة",
    "correct_ans": "لا يتم الإدخال"
  },
  {
    "title": "في كود الإدخال، ماذا يعني أن نصل إلى مؤشر NULL؟",
    "answer_1": "القيمة موجودة",
    "answer_2": "مكان مناسب لإدخال عقدة جديدة",
    "answer_3": "يجب إيقاف الإدخال",
    "answer_4": "الشجرة فارغة",
    "correct_ans": "مكان مناسب لإدخال عقدة جديدة"
  },
  {
    "title": "عند حذف عقدة ورقية، ماذا يحدث لمؤشر الأب؟",
    "answer_1": "يبقى كما هو",
    "answer_2": "يشير إلى NULL",
    "answer_3": "يشير إلى الجذر",
    "answer_4": "يشير إلى الابن الأيمن",
    "correct_ans": "يشير إلى NULL"
  },
  {
    "title": "في حالة حذف عقدة لها ابن واحد، كيف يتم الربط؟",
    "answer_1": "الأب يشير إلى NULL",
    "answer_2": "الأب يشير إلى الابن الوحيد",
    "answer_3": "الابن يشير إلى الجذر",
    "answer_4": "يتم حذف الشجرة",
    "correct_ans": "الأب يشير إلى الابن الوحيد"
  },
  {
    "title": "في حذف عقدة لها ابنان، من أين نبدأ البحث عن العقدة البديلة؟",
    "answer_1": "الفرع الأيسر",
    "answer_2": "الفرع الأيمن",
    "answer_3": "الجذر",
    "answer_4": "العقدة نفسها",
    "correct_ans": "الفرع الأيمن"
  },
  {
    "title": "أي تصرّف يؤدي إلى كسر خاصية BST أثناء الإدخال؟",
    "answer_1": "الانتقال يسارًا عند قيمة أصغر",
    "answer_2": "الانتقال يمينًا عند قيمة أكبر",
    "answer_3": "إدخال قيمة أكبر في الفرع الأيسر",
    "answer_4": "التوقف عند NULL",
    "correct_ans": "إدخال قيمة أكبر في الفرع الأيسر"
  },
  {
    "title": "في بناء Heap من مصفوفة، لماذا نبدأ عملية heapify من آخر عقدة غير ورقية؟",
    "answer_1": "لأنها الجذر",
    "answer_2": "لأن العقد الورقية لا تحتاج معالجة",
    "answer_3": "لأنها أكبر عقدة",
    "answer_4": "لتقليل عدد العناصر",
    "correct_ans": "لأن العقد الورقية لا تحتاج معالجة"
  },
  {
    "title": "في كود حذف الجذر من Heap، ما أول خطوة يتم تنفيذها قبل إعادة ترتيب Heap؟",
    "answer_1": "حذف آخر عنصر",
    "answer_2": "نقل آخر عنصر إلى مكان الجذر",
    "answer_3": "استدعاء heapifyUp",
    "answer_4": "إيقاف التنفيذ",
    "correct_ans": "نقل آخر عنصر إلى مكان الجذر"
  },
  {
    "title": "اعتبر الكود التالي:\n<pre>int partition(int[] a, int left, int right) {\n    int pivot = a[(left + right) / 2];\n\n    while (left <= right) {\n        while (a[left] < pivot)\n            left++;\n        while (a[right] > pivot)\n            right--;\n\n        if (left <= right) {\n            swap(a, left, right);\n            left++;\n            right--;\n        }\n    }\n    return left;\n}</pre>\nما الذي تمثله القيمة المعادة من الدالة partition؟",
    "answer_1": "موقع المحور النهائي",
    "answer_2": "عدد التبديلات",
    "answer_3": "نقطة الفصل بين القسمين الناتجين",
    "answer_4": "عدد العناصر الأصغر من المحور",
    "correct_ans": "نقطة الفصل بين القسمين الناتجين"
  },
  {
    "title": "لدينا الكود التالي: \n <pre>function mergeSort(low, high, t) {\n    if(low != high) {\n        let mid = parseInt((low + high) / 2);\n        mergeSort(low, mid, t);\n        mergeSort(___Here___);\n        merge(low, mid, high, t);\n    }\n}</pre>\nأي مما يلي يجب وضعه في المكان Here :",
    "answer_1": "mid - 1, high, t",
    "answer_2": "mid, high, t",
    "answer_3": "mid + 1, high, t",
    "answer_4": "mid, high - 1, t",
    "correct_ans": "mid + 1, high, t"
  },
  {
    "title": "استدعاء التابع MergeSort(2, 3, a) يقوم ب:",
    "answer_1": "Error",
    "answer_2": "ترتيب العنصر الثاني والثالث في a ",
    "answer_3": "حذف العنصرين الثاني والثالث من a",
    "answer_4": "لا يقوم بشيء",
    "correct_ans": "ترتيب العنصر الثاني والثالث في a "
  },
  {
    "title": "<pre>while(j <= high) {\n        aux[k] = t[j];\n        j++;\n        k++;\n    }\n</pre> وظيفة الحلقة السابقة في تابع merge هي :",
    "answer_1": "نسخ عناصر المصفوفة الثانية إلى المصفوفة المساعدة في حال بقاء عناصر بالمصفوفة الثانية",
    "answer_2": "حذف العناصر المكررة في المصفوقة المساعدة",
    "answer_3": "نسخ عناصر المصفوفة الثانية إلى المصفوفة المساعدة في حال بقاء عناصر بالمصفوفة الأولى",
    "answer_4": "نسخ t إلى aux",
    "correct_ans": "نسخ عناصر المصفوفة الثانية إلى المصفوفة المساعدة في حال بقاء عناصر بالمصفوفة الثانية"
  },
  {
    "title": "<pre>\nfor (i = 2; i <= n; i++)\n{\n        elt = x[i];\n        s = i;\n        f = s / 2;\n        while (___Here___)\n        {\n        x[s] = x[f];\n        s = f;\n        if (s > 1) f = s / 2;\n        else f = 1;\n        }\n        x[s] = elt;\n}</pre> ما الشرط الواجب وضعه في المكان Here وفق HeapSort ؟",
    "answer_1": "<span dir='ltr'>(s < 1) && (x[f] < elt)</span>",
    "answer_2": "<span dir='ltr'>(s > 1) && (x[f] < elt)</span>",
    "answer_3": "<span dir='ltr'>(s > 1) || (x[f] < elt)</span>",
    "answer_4": "<span dir='ltr'>(s < 1) || (x[f] < elt)</span>",
    "correct_ans": "<span dir='ltr'>(s > 1) && (x[f] < elt)</span>"
  },
  {
    "title": "<pre>\nfor (i = 2; i <= n; i++)\n{\n        elt = x[i];\n        s = i;\n        f = ___Here___;\n        while ((s > 1) && (x[f] < elt))\n        {\n        x[s] = x[f];\n        s = f;\n        if (s > 1) f = s / 2;\n        else f = 1;\n        }\n        x[s] = elt;\n}</pre> ما القيمة الواجب وضعها في المكان Here وفق HeapSort ؟",
    "answer_1": "s * 2",
    "answer_2": "s - 1",
    "answer_3": "s / 2",
    "answer_4": "s * s",
    "correct_ans": "s / 2"
  },
  {
    "title": "<pre>while ((s > 0) && (iValue < value))\n{\nx[f] = x[s];\nf = s;\ns = ___Here___;\nif (s+1 <= i-1)\n        if (x[s] < x[s+1]) s = s + 1;\nif (s < i) value = x[s];\nelse s = 0;\n}</pre> ما القيمة الواجب وضعها في المكان Here وفق HeapSort ؟",
    "answer_1": "f * 2",
    "answer_2": "s / 2",
    "answer_3": "f / 2",
    "answer_4": "s * 2",
    "correct_ans": "f * 2"
  },
  {
    "title": "<pre>while ((s > 0) && (iValue < value))\n{\n___Here___\nf = s;\ns = f * 2;\nif (s+1 <= i-1)\n        if (x[s] < x[s+1]) s = s + 1;\nif (s < i) value = x[s];\nelse s = 0;\n}</pre> ما التعليمة الواجب وضعها في المكان Here وفق HeapSort ؟",
    "answer_1": "s = f;",
    "answer_2": "f = s;",
    "answer_3": "x[s] = x[f];",
    "answer_4": "x[f] = x[s];",
    "correct_ans": "x[f] = x[s];"
  },
  {
    "title": "<pre>while (___Here___) {\n  if (P.value == key) {\n    found = true;\n    } else {\n      Q = P;\n      if (key < P.value) {\n      P = P.left;\n      } else {\n      P = P.right;\n      }\n  }\n}</pre> ما الشرط الواجب وضعه في المكان Here وفق HeapSort ؟",
    "answer_1": "<span dir='ltr'>(P != null) || (!found)</span>",
    "answer_2": "<span dir='ltr'>(P != null) && (!found)</span>",
    "answer_3": "<span dir='ltr'>(P != null) && (found)</span>",
    "answer_4": "<span dir='ltr'>(P != null) || (!found)</span>",
    "correct_ans": "<span dir='ltr'>(P != null) && (!found)</span>"
  },
  {
    "title": "إذا كان لدينا الجنود التالية أسماؤهم  A,B,C,D وبدأنا العد من الجندي  Aوكانت خطوة العد  n=3 فمن سيكون الجندي الناجي وفق خوارزمية جوزيف ؟",
    "answer_1": "A",
    "answer_2": "B",
    "answer_3": "C",
    "answer_4": "D",
    "correct_ans": "A"
  },
  {
    "title": "إذا كان لدينا الجنود التالية أسماؤهم  A,B,C,D,E وبدأنا العد من الجندي  Aوكانت خطوة العد  n=2 فمن سيكون الجندي الناجي وفق خوارزمية جوزيف ؟",
    "answer_1": "A",
    "answer_2": "E",
    "answer_3": "C",
    "answer_4": "D",
    "correct_ans": "C"
  },
  {
    "title": "باعتبار أن الجذر ذا دليل 1 فإن دليل (index) الولد اليميني لعقدة ما يساوي",
    "answer_1": "دليل الأب * 2 + 1",
    "answer_2": "دليل الأب",
    "answer_3": "دليل الأب * 2",
    "answer_4": "دليل الأب + 1",
    "correct_ans": "دليل الأب * 2 + 1"
  },
  {
    "title": "باعتبار أن الجذر ذا دليل 1 فإن دليل (index) الولد اليساري لعقدة ما يساوي",
    "answer_1": "دليل الأب * 2 + 1",
    "answer_2": "دليل الأب",
    "answer_3": "دليل الأب * 2",
    "answer_4": "دليل الأب + 1",
    "correct_ans": "دليل الأب * 2"
  },
  {
    "title": "تعتمد نظرية هوفمان على إعطاء الشيفرة الأكبر ل:",
    "answer_1": "الحرف الأكبر",
    "answer_2": "الحرف الأكثر تكراراً",
    "answer_3": "الحرف الأقل تكراراً",
    "answer_4": "الحرف الأصغر",
    "correct_ans": "الحرف الأقل تكراراً"
  },
  {
    "title": "ليكن لدينا التابع :<pre>public static int findminfreq(int p, NodeType node[]) {\n        int min = 99, l = -1, k;\n        for(k = 0; k < p; k++)\n                if(_____Here_____) {\n                        min = node[k].freq;\n                        l = k;\n                }\n        node[l].freq = false;\n        return l;\n}</pre>ما الشرط الواجب وضعه في المكان Here وفق هوفمان ؟",
    "answer_1": "(node[k].freq < min) && (node[k].del)",
    "answer_2": "(node[k].freq > min) && (node[k].del)",
    "answer_3": "(node[k].freq < min) || (node[k].del)",
    "answer_4": "(node[k].freq <= min) && (node[k].del)",
    "correct_ans": "(node[k].freq < min) && (node[k].del)"
  },
  {
    "title": "أي من التسلسلات التالية تمثل Heap صحيحة؟",
    "answer_1": "<span dir='ltr'>16 14 10 4 7 9 3 2 8 1</span>",
    "answer_2": "<span dir='ltr'>16 14 10 8 7 9 3 2 4 1</span>",
    "answer_3": "<span dir='ltr'>16 14 10 8 1 9 3 2 4 7</span>",
    "answer_4": "<span dir='ltr'>16 14 3 4 1 9 10 8 2 7</span>",
    "correct_ans": "<span dir='ltr'>16 14 10 8 7 9 3 2 4 1</span>"
  },
  {
    "title": "أي من المصفوفات التالية تمثل Binary Max-Heap؟",
    "answer_1": "<span dir='ltr'>[26, 13, 17, 14, 11, 9, 15]</span>",
    "answer_2": "<span dir='ltr'>[26, 15, 14, 17, 11, 9, 13]</span>",
    "answer_3": "<span dir='ltr'>[26, 15, 17, 14, 11, 9, 13]</span>",
    "answer_4": "<span dir='ltr'>[26, 15, 13, 14, 11, 9, 17]</span>",
    "correct_ans": "<span dir='ltr'>[26, 15, 17, 14, 11, 9, 13]</span>"
  },
  {
    "title": "لدينا Binary Max-Heap ممثل بالمصفوفة:\n<pre>25, 14, 16, 13, 10, 8, 12</pre>\nما هو شكل المصفوفة بعد تنفيذ عمليتي حذف متتاليتين؟",
    "answer_1": "<span dir='ltr'>14,13,8,12,10</span>",
    "answer_2": "<span dir='ltr'>14,12,13,10,8</span>",
    "answer_3": "<span dir='ltr'>14,13,12,8,10</span>",
    "answer_4": "<span dir='ltr'>14,13,12,10,8</span>",
    "correct_ans": "<span dir='ltr'>14,13,12,8,10</span>"
  },
  {
    "title": "ما هو شكل المصفوفة بعد تنفيذ عمليتي حذف متتاليتين على Binary Max-Heap ممثل بالمصفوفة:\n<pre>30, 20, 15, 10, 8, 12, 6</pre>",
    "answer_1": "<span dir='ltr'>20,10,15,6,8</span>",
    "answer_2": "<span dir='ltr'>20,15,12,10,8</span>",
    "answer_3": "<span dir='ltr'>20,15,10,8,6</span>",
    "answer_4": "<span dir='ltr'>20,15,10,6,8</span>",
    "correct_ans": "<span dir='ltr'>20,15,10,8,6</span>"
  },
  {
    "title": "لدينا المصفوفة التالية:\n<pre>⟨89, 19, 50, 17, 12, 15, 2, 5, 7, 11, 6, 9, 100⟩</pre>\nما هو أقل عدد من عمليات التبديل اللازمة لتحويلها إلى Max-Heap؟",
    "answer_1": "4",
    "answer_2": "5",
    "answer_3": "2",
    "answer_4": "3",
    "correct_ans": "3"
  },
  {
    "title": "ما هو أقل عدد من عمليات التبديل اللازمة لتحويل المصفوفة التالية إلى Max-Heap؟\n<pre>⟨45, 20, 30, 10, 15, 25, 5, 8, 12⟩</pre>",
    "answer_1": "2",
    "answer_2": "3",
    "answer_3": "4",
    "answer_4": "5",
    "correct_ans": "2"
  },
  {
    "title": "يعطى العبور Postorder لشجرة ما بالشكل : <pre>3, 5, 7, 9, 4, 17, 16, 20, 18, 15, 14</pre> ما هو الجذر الرئيسي في الشجرة السابقة ؟",
    "answer_1": "14",
    "answer_2": "17",
    "answer_3": "3",
    "answer_4": "16",
    "correct_ans": "14"
  },
  {
    "title": "أي مما يلي هو عبور من الشكل inorder لشجرة متوازنة جذرها يساوي ال45",
    "answer_1": "<span dir='ltr'>5, 12, 14, 45, 67, 68, 90</span>",
    "answer_2": "<span dir='ltr'>5, 10, 15, 25, 45</span>",
    "answer_3": "<span dir='ltr'>45, 15, 25, 5, 10, 2</span>",
    "answer_4": "<span dir='ltr'>12, 45, 89, 56, 87</span>",
    "correct_ans": "<span dir='ltr'>5, 12, 14, 45, 67, 68, 90</span>"
  },
  {
    "title": "يتم إدخال الأعداد التالية إلى BST فارغة على الترتيب:<pre>10, 1, 3, 5, 15, 12, 16</pre>ما هو طول الشجرة ؟",
    "answer_1": "2",
    "answer_2": "3",
    "answer_3": "4",
    "answer_4": "5",
    "correct_ans": "3"
  },
  {
    "title": "وفق هوفمان نعبر عن الفرع اليميني بالرمز:",
    "answer_1": "1",
    "answer_2": "0",
    "answer_3": "null",
    "answer_4": "right",
    "correct_ans": "1"
  },
  {
    "title": "أثناء تهيئتنا للعقد في خوارزمية هوفمان<pre>for (int i = 0; ___Here___; i++)\n{\n  node[i] = new NodeType();\n}</pre> ما شرط التوقف الواجب وضعه في المكان Here",
    "answer_1": "i < 2 * n - 1",
    "answer_2": "i <= 2 * n - 1",
    "answer_3": "i < 2 * n",
    "answer_4": "i <= 2 * n",
    "correct_ans": "i < 2 * n - 1"
  }
]